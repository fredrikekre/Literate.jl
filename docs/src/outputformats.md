# [**4.** Output formats](@id Output-formats)

When the source is parsed, and has been processed it is time to render the output.
We will consider the following source snippet:

```@eval
import Markdown
Markdown.parse("```julia\n" * rstrip(read("outputformats.jl", String)) * "\n```")
```

and see how this is rendered in each of the output formats.

## [**4.1.** Markdown output](@id Markdown-output)

Markdown output is generated by [`Literate.markdown`](@ref). There exist various "flavors"
of markdown and Literate supports some different flavors, see [Markdown flavors](@ref).
The default flavor is `Literate.DocumenterFlavor()` and, as the name suggest, it generates
markdown files meant to be used together with [Documenter.jl]
(https://juliadocs.github.io/Documenter.jl). The output of the source snippet above is as
follows:

```@eval
import Markdown
file = joinpath(@__DIR__, "../src/generated/name.md")
str = "`````markdown\n" * rstrip(read(file, String)) * "\n`````"
rm(file)
Markdown.parse(str)
```

We note that lines starting with `# ` are printed as regular markdown,
and the code lines have been wrapped in `@example` blocks. We also note that
an `@meta` block have been added, that sets the `EditURL` variable. This is used
by Documenter to redirect the "Edit on GitHub" link for the page,
see [Interaction with Documenter](@ref).

The `@example` blocks are wrapped in 4 consecutive backticks so as to allow for docstrings
containing triple backticks, for example:
````julia
"""
This function perform the following calculation:
```math
    x_1 + x_2
```
"""
f(x) = x[1] + x[2]
````
If your Julia code itself contains 4 consecutive backticks, you can use the keyword
argument `codefence` to setup 5 backticks for code blocks, see [Configuration](@ref).

It possible to configure `Literate.markdown` to also evaluate code snippets, capture the
result and include it in the output, by passing `execute=true` as a keyword argument.
The result of the first code-block in the example above would then become
`````markdown
````julia
x = 1//3
````
````
1//3
````
`````

In this example the output is just plain text. However, if the resulting value of the code
block can be displayed as an image (image/png or image/jpeg), HTML (text/html) or markdown
(text/markdown) Literate will include the richest representation of the output.

!!! note
    Since Documenter executes and captures results of `@example` block it is not necessary
    to use `execute=true` for markdown output that is meant to be used as input to
    Documenter.

See the section about [Configuration](@ref) for more information about how to configure the
behavior and resulting output of [`Literate.markdown`](@ref).

```@docs
Literate.markdown
```

### Markdown flavors

Literate can output markdown in different flavors. The flavor is specified using the
`flavor` keyword argument. The following flavors are currently supported:

 - `flavor = Literate.DocumenterFlavor()`: this is the default flavor and the output is
   meant to be used as input to [Documenter.jl](https://github.com/JuliaDocs/Documenter.jl).
 - `flavor = Literate.CommonMarkFlavor()`: this outputs markdown that has the flavor of the
   [CommonMark](https://commonmark.org/) specification.
 - `flavor = Literate.FranklinFlavor()`: this outputs markdown meant to be used as input
   to [Franklin.jl](https://franklinjl.org/).


## [**4.2.** Notebook output](@id Notebook-output)

Notebook output is generated by [`Literate.notebook`](@ref). The (default) notebook output
of the source snippet can be seen here: [notebook.ipynb](generated/notebook.ipynb).

We note that lines starting with `# ` are placed in markdown cells,
and the code lines have been placed in code cells. By default the notebook
is also executed and output cells populated. The current working directory
is set to the specified output directory the notebook is executed.

See the section about [Configuration](@ref) for how to configure the behavior and resulting
output of [`Literate.notebook`](@ref).

```@docs
Literate.notebook
```

### Notebook metadata

Jupyter notebook cells (both code cells and markdown cells) can contain metadata. This is enabled
in Literate by the `%%` token, similar to
[Jupytext](https://jupytext.readthedocs.io/en/latest/formats.html#the-percent-format).
The format is as follows

```
%% optional ignored text [type] {optional metadata JSON}
```

Cell metadata can, for example, be used for
[nbgrader](https://nbgrader.readthedocs.io/en/stable/contributor_guide/metadata.html)
and the [reveal.js](https://github.com/hakimel/reveal.js) notebook extension
[RISE](https://github.com/damianavila/RISE).

The following would create a 3 slide deck with RISE:

```julia
#nb # %% A slide [markdown] {"slideshow": {"slide_type": "slide"}}
# # Some title
#
# We're using `#nb` so the metadata is only included in notebook output

#nb %% A slide [code] {"slideshow": {"slide_type": "fragment"}}
x = 1//3
y = 2//5

#nb # %% A slide [markdown] {"slideshow": {"slide_type": "subslide"}}
# For more information about RISE, see [the docs](https://rise.readthedocs.io/en/stable/usage.html)
```

## [**4.3.** Script output](@id Script-output)

Script output is generated by [`Literate.script`](@ref). The (default) script output of the
source snippet above is as follows:

```@eval
import Markdown
file = joinpath(@__DIR__,  "../src/generated/outputformats.jl")
str = "```julia\n" * rstrip(read(file, String)) * "\n```"
rm(file)
Markdown.parse(str)
```

We note that lines starting with `# ` are removed and only the
code lines have been kept.

See the section about [Configuration](@ref) for how to configure the behavior and resulting
output of [`Literate.script`](@ref).

```@docs
Literate.script
```

## [**4.4.** Configuration](@id Configuration)

The behavior of [`Literate.markdown`](@ref), [`Literate.notebook`](@ref) and
[`Literate.script`](@ref) can be configured by keyword arguments. There are two
ways to do this; pass `config::Dict` as a keyword argument, or pass individual
keyword arguments.

!!! note "Configuration precedence"
    Individual keyword arguments take precedence over the `config` dictionary, so for e.g.
    `Literate.markdown(...; config = Dict("name" => "hello"), name = "world")` the
    resulting configuration for `name` will be `"world"`. Both individual keyword arguments
    and the `config` dictionary take precedence over the default.

Available configurations with description and default values are given in the reference for
[`Literate.DEFAULT_CONFIGURATION`](@ref) just below.


```@docs
Literate.DEFAULT_CONFIGURATION
```
