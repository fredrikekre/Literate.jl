var documenterSearchIndex = {"docs":
[{"location":"documenter/#Interaction-with-Documenter","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"Literate can be used for any purpose, it spits out regular markdown files, and notebooks. Typically, though, these files will be used to render documentation for your package. The generators (Literate.markdown, Literate.notebook and Literate.script) supports a keyword argument documenter that lets the generator perform some extra things, keeping in mind that the source code have been written with Documenter.jl in mind. So let's take a look at what will happen if we set documenter = true:","category":"page"},{"location":"documenter/#[Literate.markdown](@ref):","page":"6. Interaction with Documenter.jl","title":"Literate.markdown:","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"The default code fence will change from\n```julia\n# code\n```\nto Documenters @example blocks:\n```@examples $(name)\n# code\n```\nThe following @meta block will be added to the top of the markdown page, which redirects the \"Edit on GitHub\" link on the top of the page to the source file rather than the generated .md file:\n```@meta\nEditURL = \"$(relpath(inputfile, outputdir))\"\n```","category":"page"},{"location":"documenter/#[Literate.notebook](@ref):","page":"6. Interaction with Documenter.jl","title":"Literate.notebook:","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"Documenter style @refs, @extrefs and @id will be removed. This means that you can use @ref, @extref and @id in the source file without them leaking to the notebook.\nDocumenter style markdown math\n```math\n\\int f dx\n```\nis replaced with notebook compatible\n$$\n\\int f dx\n$$\nDocumenter style admonitions\n!!! note\n    An interesting note.\n\n!!! warning \"Warning title text\"\n    An important warning.\nare replaced with notebook compatible quote blocks\n> **Note**\n>\n> An interesting note.\n\n> **Warning title text**\n>\n> An important warning.\nWhereas Documenter requires HTML blocks to be escaped\n```@raw html\n<tag>...</tag>\n```\nthe output to a notebook markdown cell will be raw HTML\n<tag>...</tag>","category":"page"},{"location":"documenter/#[Literate.script](@ref):","page":"6. Interaction with Documenter.jl","title":"Literate.script:","text":"","category":"section"},{"location":"documenter/","page":"6. Interaction with Documenter.jl","title":"6. Interaction with Documenter.jl","text":"Documenter style @refs, @extrefs and @id will be removed. This means that you can use @ref, @extref and @id in the source file without them leaking to the script.","category":"page"},{"location":"customprocessing/#Custom-pre-and-post-processing","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"","category":"section"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Since all packages are different, and may have different demands on how to create a nice example for the documentation it is important that the package maintainer does not feel limited by the by default provided syntax that this package offers. While you can generally come a long way by utilizing line filtering there might be situations where you need to manually hook into the generation and change things. In Literate this is done by letting the user supply custom pre- and post-processing functions that may do transformation of the content.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"All of the generators (Literate.markdown, Literate.notebook and Literate.script) accept preprocess and postprocess keyword arguments. The default \"transformation\" is the identity function. The input to the transformation functions is a String, and the output should be the transformed String.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"preprocess is sent the raw input that is read from the source file (modulo the default line ending transformation). postprocess is given different things depending on the output: For markdown and script output postprocess is given the content String just before writing it to the output file, but for notebook output postprocess is given the dictionary representing the notebook, since, in general, this is more useful.","category":"page"},{"location":"customprocessing/#Example:-Adding-current-date","page":"5. Custom pre- and post-processing","title":"Example: Adding current date","text":"","category":"section"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"As an example, lets say we want to splice the date of generation into the output. We could of course update our source file before generating the docs, but we could instead use a preprocess function that splices the date into the source for us. Consider the following source file:","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"# # Example\n# This example was generated DATEOFTODAY\n\nx = 1 // 3","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"where DATEOFTODAY is a placeholder, to make it easier for our preprocess function to find the location. Now, lets define the preprocess function, for example","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"function update_date(content)\n    content = replace(content, \"DATEOFTODAY\" => Date(now()))\n    return content\nend","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"which would replace every occurrence of \"DATEOFTODAY\" with the current date. We would now simply give this function to the generator, for example:","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Literate.markdown(\"input.jl\", \"outputdir\"; preprocess = update_date)","category":"page"},{"location":"customprocessing/#Example:-Replacing-include-calls-with-included-code","page":"5. Custom pre- and post-processing","title":"Example: Replacing include calls with included code","text":"","category":"section"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Let's say that we have some individual example files file1, file2, ... etc. that are runnable and also following the style of Literate. These files could be for example used in the test suite of your package.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"We want to group them all into a single page in our documentation, but we do not want to copy paste the content of file1, ... for robustness: the files are included in the test suite and some changes may occur to them. We want these changes to also be reflected in the documentation.","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"A very easy way to do this is using preprocess to interchange include statements with file content. First, create a runnable .jl following the format of Literate","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"# # Replace includes\n# This is an example to replace `include` calls with the actual file content.\n\ninclude(\"file1.jl\")\n\n# Cool, we just saw the result of the above code snippet. Here is one more:\n\ninclude(\"file2.jl\")","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Let's say we have saved this file as examples.jl. Then, you want to properly define a pre-processing function:","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"function replace_includes(str)\n\n    included = [\"file1.jl\", \"file2.jl\"]\n\n    # Here the path loads the files from their proper directory,\n    # which may not be the directory of the `examples.jl` file!\n    path = \"directory/to/example/files/\"\n\n    for ex in included\n        content = read(path*ex, String)\n        str = replace(str, \"include(\\\"$(ex)\\\")\" => content)\n    end\n    return str\nend","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"(of course replace included with your respective files)","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Finally, you simply pass this function to e.g. Literate.markdown as","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"Literate.markdown(\"examples.jl\", \"path/to/save/markdown\";\n                  name = \"markdown_file_name\", preprocess = replace_includes)","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"and you will see that in the final output file (here markdown_file_name.md) the include statements are replaced with the actual code to be included!","category":"page"},{"location":"customprocessing/","page":"5. Custom pre- and post-processing","title":"5. Custom pre- and post-processing","text":"This approach is used for generating the examples in the documentation of the TimeseriesPrediction.jl package. The  example files, included together in the  stexamples.jl file, are processed by literate via this make.jl  file to generate the markdown and code cells of the documentation.","category":"page"},{"location":"tips/#tips-and-tricks","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"This section lists some tips and tricks that might be useful for using Literate.","category":"page"},{"location":"tips/#notebook-filesize","page":"7. Tips and tricks","title":"Filesize of generated notebooks","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"When Literate executes a notebook the return value, i.e. the result of the last Julia expression in each cell is captured. By default Literate generates multiple renderings of the result in different output formats or MIMEs, just like IJulia.jl does. All of these renderings are embedded in the notebook and it is up to the notebook frontend viewer to select the most appropriate format to show to the user.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"A common example is images, which can often be displayed in multiple formats, e.g. PNG (image/png), SVG (image/svg+xml) and HTML (text/html). As a result, the filesize of the generated notebook can become large.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"In order to remedy this you can use the clever Julia package DisplayAs to limit the output capabilities of an object. For example, to \"force\" an image to be captures as image/png only, you can use","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"import DisplayAs\nimg = plot(...)\nimg = DisplayAs.PNG(img)","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"This can save some memory, since the image is never captured in e.g. SVG or HTML formats.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"note: Note\nIt is best to always let the object be showable as text/plain. This can be achieved by nested calls to DisplayAs output types. For example, to limit an image img to be showable as just image/png and text/plain you can useimg = plot(...)\nimg = DisplayAs.Text(DisplayAs.PNG(img))","category":"page"},{"location":"tips/#printing-tables-in-markdown","page":"7. Tips and tricks","title":"Printing tables in Markdown","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Tables that support the Tables.jl interface can be included in Markdown output with the lightweight package MarkdownTables.jl.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"using MarkdownTables\ntable = [(a = 1, b = 2), (a = 3, b = 4)]\ntable |> markdown_table()","category":"page"},{"location":"tips/#admonitions-md","page":"7. Tips and tricks","title":"Adding admonitions using compound line filtering","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Admonitions are a useful feature for drawing attention to particular elements of  documentation. They are documented in Documenter.jl and an example of their use can be seen above in the blue 'note' box. Admonitions is a specific Julia markdown feature, and they are not recognized by either common mark or Jupyter notebooks. The md line filter can be used to make sure admonitions only show up in markdown output, for example:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"#md # !!! note \"Be aware!\"\n#md #     This a note style admonition!","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"It is important to note that both #md and the second # are required. Literate.jl interprets the first #md as a markdown exclusive line, and then strips it out. The  second # tells Literate.jl that the line should be parsed as markdown and not a  Julia code block. If you only include #md and not the second # then it will  be parsed into Julia example block in the final documentation and not an actual  admonition.","category":"page"},{"location":"tips/#admonitions-compatibility","page":"7. Tips and tricks","title":"Custom parsing for markdown and notebook compatible admonitions","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"As mentioned above, admonitions are not compatible with Jupyter notebooks. (Though at time of writing this documentation, this is an open issue in Jupyter so may change in the future.) For now, we can write a custom preprocessor function so that admonitions are interpreted as quotes (with their own special formatting) in notebooks and proper admonitions in markdown. For the case of note admonitions, this can be written as follows:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"function md_note(str)\n    str = replace(str, r\"^#note # (.*)$\"m => s\"\"\"\n    # !!! note\n    #     \\1\"\"\")\n    return str\nend\n\nfunction nb_note(str)\n    str = replace(str, r\"^#note # (.*)$\"m => s\"\"\"\n    # > *Note*\n    # > \\1\"\"\")\n    return str\nend\n\nusing Literate\n\nLiterate.markdown(\"example.jl\", \"tmp/\"; preprocess = md_note)\n\nLiterate.notebook(\"example.jl\", \"tmp/\"; preprocess = nb_note)","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"This will allow us to turn the following source code in example.jl:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"#note # This is a useful note.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"into the correct admonition syntax in the markdown file generated:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"!!! note\n    This is a useful note.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"and a quotation style formatting in the generated notebook cell:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"> *Note*\n> This is a useful note.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"which, in an actual notebook cell, will look similar to:","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Note\nThis is a useful note.","category":"page"},{"location":"tips/#debug-execution","page":"7. Tips and tricks","title":"Debugging code execution","text":"","category":"section"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"When Literate is executing code (i.e. when execute = true is set), it does so quietly. All the output gets captured and nothing gets printed into the terminal. This can make it tricky to know where things go wrong, e.g. when the execution stalls due to an infinite loop.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"To help debug this, Literate has an @debug statement that prints out each code block that is being executed. In general, to enable the printing of Literate's @debug statements, you can set the JULIA_DEBUG environment variable to \"Literate\".","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"The easiest way to do that is to set the variable in the Julia session before running Literate by doing","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"ENV[\"JULIA_DEBUG\"]=\"Literate\"","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"Alternatively, you can also set the environment variable before starting the Julia session, e.g.","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"$ JULIA_DEBUG=Literate julia","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"or by wrapping the Literate calls in an withenv block","category":"page"},{"location":"tips/","page":"7. Tips and tricks","title":"7. Tips and tricks","text":"withenv(\"JULIA_DEBUG\" => \"Literate\") do\n    Literate.notebook(\"myscript.jl\"; execute=true)\nend","category":"page"},{"location":"pipeline/#Processing-pipeline","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The generation of output follows the same pipeline for all output formats:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Pre-processing\nParsing\nDocument generation\nPost-processing\nWriting to file","category":"page"},{"location":"pipeline/#Pre-processing","page":"3. Processing pipeline","title":"3.1. Pre-processing","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The first step is pre-processing of the input file. The file is read to a String. The first processing step is to apply the user specified pre-processing function, see Custom pre- and post-processing.","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The next step is to perform all of the built-in default replacements. CRLF style line endings (\"\\r\\n\") are replaced with LF line endings (\"\\n\") to simplify internal processing. Next, line filtering is performed, see Filtering lines, meaning that lines starting with #md, #nb or #jl are handled (either just the token itself is removed, or the full line, depending on the output target). The last pre-processing step is to expand the convenience \"macros\" described in Default replacements is expanded.","category":"page"},{"location":"pipeline/#Parsing","page":"3. Processing pipeline","title":"3.2. Parsing","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"After the preprocessing the file is parsed. The first step is to categorize each line and mark them as either markdown or code according to the rules described in the Syntax section. Lets consider the example from the previous section with each line categorized:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# # Rational numbers                                                     <- markdown\n#                                                                        <- markdown\n# In julia rational numbers can be constructed with the `//` operator.   <- markdown\n# Lets define two rational numbers, `x` and `y`:                         <- markdown\n                                                                         <- code\n## Define variable x and y                                               <- code\nx = 1 // 3                                                               <- code\ny = 2 // 5                                                               <- code\n                                                                         <- code\n# When adding `x` and `y` together we obtain a new rational number:      <- markdown\n                                                                         <- code\nz = x + y                                                                <- code","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"In the next step the lines are grouped into \"chunks\" of markdown and code. This is done by simply collecting adjacent lines of the same \"type\" into chunks:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# # Rational numbers                                                     ┐\n#                                                                        │\n# In julia rational numbers can be constructed with the `//` operator.   │ markdown\n# Lets define two rational numbers, `x` and `y`:                         ┘\n                                                                         ┐\n## Define variable x and y                                               │\nx = 1 // 3                                                               │\ny = 2 // 5                                                               │ code\n                                                                         ┘\n# When adding `x` and `y` together we obtain a new rational number:      ] markdown\n                                                                         ┐\nz = x + y                                                                ┘ code","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"In the last parsing step all empty leading and trailing lines for each chunk are removed, but empty lines within the same block are kept. The leading # tokens are also removed from the markdown chunks. Finally we would end up with the following 4 chunks:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunks #1:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# Rational numbers\n\nIn julia rational numbers can be constructed with the `//` operator.\nLets define two rational numbers, `x` and `y`:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunk #2:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"# Define variable x and y\nx = 1 // 3\ny = 2 // 5","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunk #3:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"When adding `x` and `y` together we obtain a new rational number:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Chunk #4:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"z = x + y","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"It is then up to the Document generation step to decide how these chunks should be treated.","category":"page"},{"location":"pipeline/#Custom-control-over-chunk-splits","page":"3. Processing pipeline","title":"Custom control over chunk splits","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Sometimes it is convenient to be able to manually control how the chunks are split. For example, if you want to split a block of code into two, such that they end up in two different @example blocks or notebook cells. The #- token can be used for this purpose. All lines starting with #- are used as \"chunk-splitters\":","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"x = 1 // 3\ny = 2 // 5\n#-\nz = x + y","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The example above would result in two consecutive code-chunks.","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"tip: Tip\nThe rest of the line, after #-, is discarded, so it is possible to use e.g. #------------- as a chunk splitter, which may make the source code more readable.","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"It is also possible to use #+ as a chunk splitter. The difference between #+ and #- is that #+ enables Documenter's \"continued\"-blocks, see the Documenter manual.","category":"page"},{"location":"pipeline/#Document-generation","page":"3. Processing pipeline","title":"3.3. Document generation","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"After the parsing it is time to generate the output. What is done in this step is very different depending on the output target, and it is described in more detail in the Output format sections: Markdown output, Notebook output and Script output. Using the default settings, the following is happening:","category":"page"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"Markdown output: markdown chunks are printed as-is, code chunks are put inside a code fence (defaults to @example-blocks),\nNotebook output: markdown chunks are printed in markdown cells, code chunks are put in code cells,\nScript output: markdown chunks are discarded, code chunks are printed as-is.","category":"page"},{"location":"pipeline/#Post-processing","page":"3. Processing pipeline","title":"3.4. Post-processing","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"When the document is generated the user, again, has the option to hook-into the generation with a custom post-processing function. The reason is that one might want to change things that are only visible in the rendered document. See Custom pre- and post-processing.","category":"page"},{"location":"pipeline/#Writing-to-file","page":"3. Processing pipeline","title":"3.5. Writing to file","text":"","category":"section"},{"location":"pipeline/","page":"3. Processing pipeline","title":"3. Processing pipeline","text":"The last step of the generation is writing to file. The result is written to $(outputdir)/$(name)(.md|.ipynb|.jl) where outputdir is the output directory supplied by the user (for example docs/generated), and name is a user supplied filename. It is recommended to add the output directory to .gitignore since the idea is that the generated documents will be generated as part of the build process rather than being files in the repo.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"EditURL = \"../../../examples/example.jl\"","category":"page"},{"location":"generated/example/#**8.**-Example","page":"8. Example","title":"8. Example","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"(Image: ) (Image: )","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"This is an example generated with Literate based on this source file: example.jl. You are seeing the HTML-output which Documenter has generated based on a markdown file generated with Literate. The corresponding notebook can be viewed in nbviewer here: example.ipynb, and opened in binder here: example.ipynb, and the plain script output can be found here: example.jl.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"It is recommended to have the source file available when reading this, to better understand how the syntax in the source file corresponds to the output you are seeing.","category":"page"},{"location":"generated/example/#Basic-syntax","page":"8. Example","title":"Basic syntax","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"The basic syntax for Literate is simple, lines starting with # is interpreted as markdown, and all the other lines are interpreted as code. Here is some code:","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x = 1//3\ny = 2//5","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"In markdown sections we can use markdown syntax. For example, we can write text in italic font, text in bold font and use links.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"It is possible to filter out lines depending on the output using the #md, #nb, #jl and #src tags (see Filtering lines):","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"This line starts with #md and is thus only visible in the markdown output.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"The source file is parsed in chunks of markdown and code. Starting a line with #- manually inserts a chunk break. For example, if we want to display the output of the following operations we may insert #- in between. These two code blocks will now end up in different @example-blocks in the markdown output, and two different notebook cells in the notebook output.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x + y","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x * y","category":"page"},{"location":"generated/example/#Output-capturing","page":"8. Example","title":"Output capturing","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"Code chunks are by default placed in Documenter @example blocks in the generated markdown. This means that the output will be captured in a block when Documenter is building the docs. In notebooks the output is captured in output cells, if the execute keyword argument is set to true. Output to stdout/stderr is also captured.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"note: Note\nNote that Documenter currently only displays output to stdout/stderr if there is no other result to show. Since the vector [1, 2, 3, 4] is returned from foo, the printing of \"This string is printed to stdout.\" is hidden.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"function foo()\n    println(\"This string is printed to stdout.\")\n    return [1, 2, 3, 4]\nend\n\nfoo()","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"Just like in the REPL, outputs ending with a semicolon hides the output:","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"1 + 1;\nnothing #hide","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"Both Documenter's @example block and notebooks can display images. Here is an example where we generate a simple plot using the Plots.jl package","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"using Plots\nx = range(0, stop=6π, length=1000)\ny1 = sin.(x)\ny2 = cos.(x)\nplot(x, [y1, y2])","category":"page"},{"location":"generated/example/#Custom-processing","page":"8. Example","title":"Custom processing","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"It is possible to give Literate custom pre- and post-processing functions. For example, here we insert a placeholder value y = 321 in the source, and use a preprocessing function that replaces it with y = 321 in the rendered output.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"x = 123","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"In this case the preprocessing function is defined by","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"function pre(s::String)\n    s = replace(s, \"x = 123\" => \"y = 321\")\n    return s\nend","category":"page"},{"location":"generated/example/#documenter-interaction","page":"8. Example","title":"Documenter.jl interaction","text":"","category":"section"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"In the source file it is possible to use Documenter.jl style references, such as @ref and @id. These will be filtered out in the notebook output. For example, here is a link, but it is only visible as a link if you are reading the markdown output. We can also use equations:","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"int_Omega nabla v cdot nabla u mathrmdOmega = int_Omega v f mathrmdOmega","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"using Documenters math syntax. Documenters syntax is automatically changed to \\begin{equation} ... \\end{equation} in the notebook output to display correctly.","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"","category":"page"},{"location":"generated/example/","page":"8. Example","title":"8. Example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"EditURL = \"../outputformats.jl\"","category":"page"},{"location":"generated/name/#Rational-numbers","page":"Rational numbers","title":"Rational numbers","text":"","category":"section"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"In julia rational numbers can be constructed with the // operator. Lets define two rational numbers, x and y:","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"x = 1//3","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"y = 2//5","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"When adding x and y together we obtain a new rational number:","category":"page"},{"location":"generated/name/","page":"Rational numbers","title":"Rational numbers","text":"z = x + y","category":"page"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"EditURL = \"https://github.com/fredrikekre/Literate.jl/blob/master/CHANGELOG.md\"","category":"page"},{"location":"changelog/#**9.**-Changelog","page":"9. Changelog","title":"9. Changelog","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"changelog/#[v2.20.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.20.1)-2024-10-17","page":"9. Changelog","title":"v2.20.1 - 2024-10-17","text":"","category":"section"},{"location":"changelog/#Fixed","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Errors from code evaluation (with continue_on_error = true) are now properly displayed with showerror. (#261)","category":"page"},{"location":"changelog/#[v2.20.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.20.0)-2024-10-16","page":"9. Changelog","title":"v2.20.0 - 2024-10-16","text":"","category":"section"},{"location":"changelog/#Added","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"A new keyword argument configuration continue_on_error::Bool = false has been added which controls the behavior of code execution errors. By default (continue_on_error = false) execution errors are re-thrown by Literate (as before). If continue_on_error = true is set the error is used as the block result and execution continues with following blocks. (#201, #257)\nLiterate now replaces Documenter-style admonitions when generating notebook output (#259). Concretely,\n# !!! note\n#     A note.\n\n# !!! warn \"Warning title text\"\n#     A warning.\nis replaced with\n# > **Note**\n# >\n# > A note.\n\n# > **Warning title text**\n# >\n# > A warning.","category":"page"},{"location":"changelog/#[v2.19.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.19.1)-2024-09-13","page":"9. Changelog","title":"v2.19.1 - 2024-09-13","text":"","category":"section"},{"location":"changelog/#Fixed-2","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Set :SOURCE_PATH in the task local storage to the output file when executing code so that recursive include works as expected. (#251, #252)","category":"page"},{"location":"changelog/#[v2.19.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.19.0)-2024-07-11","page":"9. Changelog","title":"v2.19.0 - 2024-07-11","text":"","category":"section"},{"location":"changelog/#Changed","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Literate.markdown, Literate.notebook, and Literate.script are marked as public in Julia version that support the public keyword. (#248)","category":"page"},{"location":"changelog/#[v2.18.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.18.0)-2024-04-17","page":"9. Changelog","title":"v2.18.0 - 2024-04-17","text":"","category":"section"},{"location":"changelog/#Added-2","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Literate will now remove DocumenterInterlinks.jl @extref links similarly to how Documenter.jl @ref and @id's are removed. (#245)","category":"page"},{"location":"changelog/#[v2.17.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.17.0)-2024-04-14","page":"9. Changelog","title":"v2.17.0 - 2024-04-14","text":"","category":"section"},{"location":"changelog/#Added-3","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Literate can now output Quarto notebooks (markdown documents with the .qmd file extension) by passing flavor = Literate.QuartoFlavor() to Literate.markdown. This feature is marked as experimental since it has not been widely tested and the Quarto-specific syntax may change before Literate version 3 depending on what the community wants or needs. (#199, #200)","category":"page"},{"location":"changelog/#[v2.16.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.16.1)-2024-01-04","page":"9. Changelog","title":"v2.16.1 - 2024-01-04","text":"","category":"section"},{"location":"changelog/#Fixed-3","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Fix removal of Documenter-style @ref links spanning multiple lines. (#224, #233)","category":"page"},{"location":"changelog/#[v2.16.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.16.0)-2023-11-08","page":"9. Changelog","title":"v2.16.0 - 2023-11-08","text":"","category":"section"},{"location":"changelog/#Added-4","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"\"Soft\" scoping rules (see e.g. https://github.com/JuliaLang/SoftGlobalScope.jl) are now available for code execution (markdown and notebook output). This is enabled by default for Jupyter notebook output (to mimic how the IJulia kernel works), and disabled otherwise. Soft scope rules can be enabled/disabled with the softscope :: Bool configuration variable. (#227, #230)","category":"page"},{"location":"changelog/#Changed-2","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"The minimum Julia version requirement for Literate >= 2.16.0 is now 1.6.0 (from 1.0.0). (#230)","category":"page"},{"location":"changelog/#[v2.15.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.15.1)-2023-11-08","page":"9. Changelog","title":"v2.15.1 - 2023-11-08","text":"","category":"section"},{"location":"changelog/#Fixed-4","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Fix a bug where Literate.markdown with execute=true would (try to) output images in the wrong directory. This only occured when passing a relative output directory. (#228, #229)","category":"page"},{"location":"changelog/#[v2.15.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.15.0)-2023-09-05","page":"9. Changelog","title":"v2.15.0 - 2023-09-05","text":"","category":"section"},{"location":"changelog/#Added-5","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Documenter style @raw html blocks are automatically handled in Jupyter notebook output (similar to how Documenter style `math blocks are rewritten to $$ blocks). (#222, #223)","category":"page"},{"location":"changelog/#[v2.14.2](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.14.2)-2023-08-28","page":"9. Changelog","title":"v2.14.2 - 2023-08-28","text":"","category":"section"},{"location":"changelog/#Fixed-5","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Remove double newline in Literate.script output. (#221)","category":"page"},{"location":"changelog/#[v2.14.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.14.1)-2023-08-04","page":"9. Changelog","title":"v2.14.1 - 2023-08-04","text":"","category":"section"},{"location":"changelog/#Fixed-6","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Update generated EditURL to use a relative path instead and let Documenter figure out the remote repository. This is required for Documenter version 1, but works also on Documenter 0.27. (#219)","category":"page"},{"location":"changelog/#[v2.14.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.14.0)-2022-09-22","page":"9. Changelog","title":"v2.14.0 - 2022-09-22","text":"","category":"section"},{"location":"changelog/#Changed-3","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Image filenames resulting from executing markdown files (Literate.markdown(...; execute=true)) have changed from a number based on the hash of the source block to the format {name}-{blocknumber}.(svg|png|...). (#204, #205)","category":"page"},{"location":"changelog/#[v2.13.4](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.13.4)-2022-06-03","page":"9. Changelog","title":"v2.13.4 - 2022-06-03","text":"","category":"section"},{"location":"changelog/#Fixed-7","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Automatic head branch detection (introduced in version 2.11.0) caused a performance regression since the git remote show command takes ~1 second. For documentation builds with many literate files this caused significant slowdowns, which is particularly annoying when doing iterative buils with eg. LiveServer.jl. Literate now caches the remote head branch on a per-repo basis, so the 1 second delay should only be noticed on the first run of the first file in a repo. As noted in the changelog entry for 2.11.0 it is also possible to specify the head branch by passing the edit_commit keyword argument. Doing so will now completely skip the slow git command. (8054d26)","category":"page"},{"location":"changelog/#[v2.13.3](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.13.3)-2022-05-21","page":"9. Changelog","title":"v2.13.3 - 2022-05-21","text":"","category":"section"},{"location":"changelog/#Fixed-8","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Update remote HEAD branch detection to use addenv instead of setenv such that e.g. ssh-agent variables are available to the git command. Also set GIT_SSH_COMMAND='ssh -o \"BatchMode yes\"' to supress prompts when using ssh. (#197)","category":"page"},{"location":"changelog/#[v2.13.2](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.13.2)-2022-04-22","page":"9. Changelog","title":"v2.13.2 - 2022-04-22","text":"","category":"section"},{"location":"changelog/#Fixed-9","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Set current working directory for markdown execution to the output directory, just like notebook execution. (#195)\nSet the apparent source file to the output file for markdown and notebook execution. (#195)","category":"page"},{"location":"changelog/#[v2.13.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.13.1)-2022-04-12","page":"9. Changelog","title":"v2.13.1 - 2022-04-12","text":"","category":"section"},{"location":"changelog/#Fixed-10","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Disable git terminal prompt when detecting remote HEAD branch. (#194)","category":"page"},{"location":"changelog/#[v2.13.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.13.0)-2022-02-18","page":"9. Changelog","title":"v2.13.0 - 2022-02-18","text":"","category":"section"},{"location":"changelog/#Changed-4","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"\"Markdown stdlib-style\" inline math (e.g. ``f(x) = x^2``) is now replaced with \"notebook style\" math ($f(x) = x^2$) for notebook output. This is already the case for display math (math). (#116, #190)","category":"page"},{"location":"changelog/#Fixed-11","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Lines with trailing #hide are not shown in output of Markdown execution with Documenter flavor. (#166, #188)","category":"page"},{"location":"changelog/#[v2.12.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.12.1)-2022-02-10","page":"9. Changelog","title":"v2.12.1 - 2022-02-10","text":"","category":"section"},{"location":"changelog/#Fixed-12","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Make sure Markdown execution picks up new definitions of display methods (by running in the latest \"world age\"). (#187)","category":"page"},{"location":"changelog/#[v2.12.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.12.0)-2022-02-01","page":"9. Changelog","title":"v2.12.0 - 2022-02-01","text":"","category":"section"},{"location":"changelog/#Changed-5","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"User input configurations can now be AbstractDicts instead of just Dicts. (#185, #186)","category":"page"},{"location":"changelog/#[v2.11.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.11.0)-2022-01-25","page":"9. Changelog","title":"v2.11.0 - 2022-01-25","text":"","category":"section"},{"location":"changelog/#Added-6","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Literate now tries to figure out the branch/commit that EditURL should point to automatically instead of always defaulting to \"master\". For typical setups the auto-detection should be sufficient, but you can also set it explicitly by passing edit_commit, for example edit_commit = \"main\". (#179, #184)","category":"page"},{"location":"changelog/#[v2.10.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.10.0)-2022-01-24","page":"9. Changelog","title":"v2.10.0 - 2022-01-24","text":"","category":"section"},{"location":"changelog/#Added-7","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Markdown execution now also support image/svg+xml. (#182, #183)","category":"page"},{"location":"changelog/#[v2.9.4](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.9.4)-2021-10-18","page":"9. Changelog","title":"v2.9.4 - 2021-10-18","text":"","category":"section"},{"location":"changelog/#Fixed-13","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Fix multiline comment support for \\r\\n line endings. (#171, #172)","category":"page"},{"location":"changelog/#[v2.9.3](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.9.3)-2021-09-01","page":"9. Changelog","title":"v2.9.3 - 2021-09-01","text":"","category":"section"},{"location":"changelog/#Fixed-14","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Fix named @examples from Literate.markdown to not contain spaces even if the source filename does. (#168, #169)","category":"page"},{"location":"changelog/#[v2.9.2](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.9.2)-2021-08-16","page":"9. Changelog","title":"v2.9.2 - 2021-08-16","text":"","category":"section"},{"location":"changelog/#Fixed-15","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Fix multiline comment support for \\r\\n line endings. (#165, #167)","category":"page"},{"location":"changelog/#[v2.9.1](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.9.1)-2021-07-30","page":"9. Changelog","title":"v2.9.1 - 2021-07-30","text":"","category":"section"},{"location":"changelog/#Fixed-16","page":"9. Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Automatic URLs from @__NBVIEWER_ROOT_URL__ and @__BINDER_ROOT_URL__ now follow the convention used in Documenter.jl to ignore build version information. (#162, #163)","category":"page"},{"location":"changelog/#[v2.9.0](https://github.com/fredrikekre/Literate.jl/releases/tag/v2.9.0)-2021-07-09","page":"9. Changelog","title":"v2.9.0 - 2021-07-09","text":"","category":"section"},{"location":"changelog/#Added-8","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Added \"Franklin flavored\" markdown output for usage with Franklin. Enable by passing the flavor keyword argument:\nLiterate.markdown(...; flavor = Literate.FranklinFlavor())\n(#146, #147, #156)\nAdded \"Documenter flavored\" markdown output as a replacement for documenter=true, and \"CommonMark flavored\" markdown output as a replacement for documenter=false. Enable by passing the flavor keyword argument:\nLiterate.markdown(...; flavor = Literate.DocumenterFlavor())\nLiterate.markdown(...; flavor = Literate.CommonMarkFlavor())\n(#159)\nAdded option to use multiline markdown strings (md\"\"\" ... \"\"\") as markdown sections. To enable, pass mdstrings=true. (#152, #149)","category":"page"},{"location":"changelog/#Changed-6","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"The default code fence for markdown output have been changed to 4 (instead of 3) backticks to allow input files with 3 backticks, which is common in e.g. docstrings or multiline Cmd. (#144, #145)\nReplacement of Documenter-style @ref and @id elements are now removed unconditionally instead of conditionally based on the (now deprecated) documenter keyword argument. (#159)","category":"page"},{"location":"changelog/#Deprecated","page":"9. Changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"The documenter keyword argument has been deprecated. For Literate.markdown the the replacement is to use flavor = Literate.DocumenterFlavor() or flavor = Literate.CommonMarkFlavor() as appropriate (see above). For Literate.notebook and Literate.script the option is now unused (see above regarding @ref and @id), and no replacement is necessary. (#159)","category":"page"},{"location":"changelog/#v2.8-2021-01-19","page":"9. Changelog","title":"v2.8 - 2021-01-19","text":"","category":"section"},{"location":"changelog/#Added-9","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Execution of notebooks now capture output of display(x) and display(mime, x) (ceff7a3).","category":"page"},{"location":"changelog/#v2.7-2021-09-12","page":"9. Changelog","title":"v2.7 - 2021-09-12","text":"","category":"section"},{"location":"changelog/#Added-10","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Multiline-style Julia comments (#= ... =#) can now be used for markdown input (dc409d0).","category":"page"},{"location":"changelog/#v2.6-2020-08-15","page":"9. Changelog","title":"v2.6 - 2020-08-15","text":"","category":"section"},{"location":"changelog/#Added-11","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"New end-of-line token #hide which filters out the line after execution in Literate.markdown(...; execute=true) (6d1aec9).\nMarkdown execution now captures the text/markdown MIME (e08ca0a).","category":"page"},{"location":"changelog/#v2.5-2020-05-14","page":"9. Changelog","title":"v2.5 - 2020-05-14","text":"","category":"section"},{"location":"changelog/#Changed-7","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"The output directory now defaults to pwd() (2ba316a).","category":"page"},{"location":"changelog/#v2.4-2020-04-23","page":"9. Changelog","title":"v2.4 - 2020-04-23","text":"","category":"section"},{"location":"changelog/#Added-12","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Markdown output can now be executed and the result included in the output by pasing execute=true to Literate.markdown. Currently captures the following MIMEs: text/plain, image/png, and image/jpeg (7e89fdb).","category":"page"},{"location":"changelog/#v2.3-2020-03-03","page":"9. Changelog","title":"v2.3 - 2020-03-03","text":"","category":"section"},{"location":"changelog/#Added-13","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Filter tokens #md, #nb, and #jl, as well as their negated counterparts, can now be placed at the end of lines (b0806ed).","category":"page"},{"location":"changelog/#v2.2-2019-11-26","page":"9. Changelog","title":"v2.2 - 2019-11-26","text":"","category":"section"},{"location":"changelog/#Added-14","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Configuration can now be passed as a config::Dict keyword argument to the generators (0f9e836).\nLink macros now works when running on GitLab CI (4e71b15).\nLiterate now supports more configuration for e.g. URL's that @__REPO_ROOT_URL__ and friends expand to (4e71b15).","category":"page"},{"location":"changelog/#v2.1-2019-10-30","page":"9. Changelog","title":"v2.1 - 2019-10-30","text":"","category":"section"},{"location":"changelog/#Added-15","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Link macros now works when running on GitHub Actions (cf2b552).","category":"page"},{"location":"changelog/#v2.0-2019-07-19","page":"9. Changelog","title":"v2.0 - 2019-07-19","text":"","category":"section"},{"location":"changelog/#Added-16","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"Negated filter tokens (#!nb, #!md and #!jl) are now supported (1d02868).\nNotebook output now support cell metadata with the %%-format (0872a96).","category":"page"},{"location":"changelog/#Changed-8","page":"9. Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"BREAKING The link macros @__REPO_ROOT_URL__, @__NBVIEWER_ROOT_URL__ and @__BINDER_ROOT_URL__ no longer include a trailing / (7af5414).\nBREAKING The (undocumented) feature of Documenter continued blocks now requires an explicit #+ chunk splitter (36e8c21).\nThe link macros @__REPO_ROOT_URL__, @__NBVIEWER_ROOT_URL__ now expands to correct paths when documentation is built with DocumentationGenerator.jl (7af5414).","category":"page"},{"location":"changelog/#v1.1-2019-04-05","page":"9. Changelog","title":"v1.1 - 2019-04-05","text":"","category":"section"},{"location":"changelog/#Added-17","page":"9. Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"New link macro @__BINDER_ROOT_URL__ for linking to notebooks mybinder.org (fa64dcd).","category":"page"},{"location":"changelog/#v1.0-2019-03-06","page":"9. Changelog","title":"v1.0 - 2019-03-06","text":"","category":"section"},{"location":"changelog/","page":"9. Changelog","title":"9. Changelog","text":"First stable release of Literate.jl, see https://discourse.julialang.org/t/ann-literate-jl/10651 for release announcement.","category":"page"},{"location":"outputformats/#Output-formats","page":"4. Output formats","title":"4. Output formats","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"When the source is parsed, and has been processed it is time to render the output. We will consider the following source snippet:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"import Markdown\nMarkdown.parse(\"```julia\\n\" * rstrip(read(\"outputformats.jl\", String)) * \"\\n```\")","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"and see how this is rendered in each of the output formats.","category":"page"},{"location":"outputformats/#Markdown-output","page":"4. Output formats","title":"4.1. Markdown output","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Markdown output is generated by Literate.markdown. There exist various \"flavors\" of markdown and Literate supports some different flavors, see Markdown flavors. The default flavor is Literate.DocumenterFlavor() and, as the name suggest, it generates markdown files meant to be used together with Documenter.jl. The output of the source snippet above is as follows:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"import Markdown\nfile = joinpath(@__DIR__, \"../src/generated/name.md\")\nstr = \"`````markdown\\n\" * rstrip(read(file, String)) * \"\\n`````\"\nrm(file)\nMarkdown.parse(str)","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"We note that lines starting with # are printed as regular markdown, and the code lines have been wrapped in @example blocks. We also note that an @meta block have been added, that sets the EditURL variable. This is used by Documenter to redirect the \"Edit on GitHub\" link for the page, see Interaction with Documenter.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"The @example blocks are wrapped in 4 consecutive backticks so as to allow for docstrings containing triple backticks, for example:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"\"\"\"\nThis function perform the following calculation:\n```math\n    x_1 + x_2\n```\n\"\"\"\nf(x) = x[1] + x[2]","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"If your Julia code itself contains 4 consecutive backticks, you can use the keyword argument codefence to setup 5 backticks for code blocks, see Configuration.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"It possible to configure Literate.markdown to also evaluate code snippets, capture the result and include it in the output, by passing execute=true as a keyword argument. The result of the first code-block in the example above would then become","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"````julia\nx = 1//3\n````\n````\n1//3\n````","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"In this example the output is just plain text. However, if the resulting value of the code block can be displayed as an image (image/png or image/jpeg), HTML (text/html) or markdown (text/markdown) Literate will include the richest representation of the output.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"note: Note\nSince Documenter executes and captures results of @example block it is not necessary to use execute=true for markdown output that is meant to be used as input to Documenter.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"See the section about Configuration for more information about how to configure the behavior and resulting output of Literate.markdown.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.markdown","category":"page"},{"location":"outputformats/#Literate.markdown","page":"4. Output formats","title":"Literate.markdown","text":"Literate.markdown(inputfile, outputdir=pwd(); config::AbstractDict=Dict(), kwargs...)\n\nGenerate a markdown file from inputfile and write the result to the directory outputdir.\n\nSee the manual section on Configuration for documentation of possible configuration with config and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"outputformats/#Markdown-flavors","page":"4. Output formats","title":"Markdown flavors","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate can output markdown in different flavors. The flavor is specified using the flavor keyword argument. The following flavors are currently supported:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"flavor = Literate.DocumenterFlavor(): this is the default flavor and the output is meant to be used as input to Documenter.jl.\nflavor = Literate.CommonMarkFlavor(): this outputs markdown that has the flavor of the CommonMark specification.\nflavor = Literate.FranklinFlavor(): this outputs markdown meant to be used as input to Franklin.jl.\nflavor = Literate.QuartoFlavor(): this outputs markdown file (with file extension .qmd) meant to be used with Quarto CLI.","category":"page"},{"location":"outputformats/#Quarto-flavor","page":"4. Output formats","title":"Quarto flavor","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"warning: Experimental feature\nQuarto markdown output is marked as and experimental feature since it has not been widely tested. Quarto-specific syntax may change before Literate version 3 depending on what the community wants and/or needs. If you use this flavor non-interactively (such as automatically building documentation) it is recommended to pin Literate to a good known version.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Quarto is an open-source scientific and technical publishing system, which can extend the range of output formats from your Literate.jl-formatted scripts. Literate.jl will produce a .qmd file, which can be used as input to Quarto CLI to produce a variety of output formats, including HTML, PDF, Word and RevealJS slides.","category":"page"},{"location":"outputformats/#Literate-Quarto-syntax-tips","page":"4. Output formats","title":"Literate + Quarto syntax tips","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"#(hashtag followed by a space) at the beginning of a line will be stripped and anything that follows will rendered as a markdown, e.g., # # Header level 1 in your script will be rendered as # Header level 1 in your .qmd file (ie, it will show as a header). Use this for adding the YAML header at the top or any Markdown blocks in the Quarto guide.\n##|(two hashtags followed by a pipe) at the beginning of a line will strip the first hashtag and interpret the remainder of the line as part of the code block. This is useful to provide Quarto commands in computation blocks, e.g., ##! echo: false would be rendered as #| echo: false and would tell Quarto not to \"echo\" the outputs of the execution (see Guide: Executions options for more commands).\nMake sure to always provide the YAML header and specify IJulia kernel when executing the file by Quarto, e.g.,\n# ---\n# title: \"My Report\"\n# jupyter: julia-1.9\n# ---\nNotice how all lines are escaped with a # so Literate.jl knows to strip the hashtags and render it as markdown (see Authoring Tutorial for more examples)\nIf any markdown components (e.g. headers) are not rendering correctly in your Quarto outputs, make sure they are surrounded by empty lines (e.g., add an empty line before and after the header) to help Quarto parse them correctly","category":"page"},{"location":"outputformats/#Configuring-Quarto-for-Julia-code-execution","page":"4. Output formats","title":"Configuring Quarto for Julia code execution","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Install Quarto CLI\nRun quarto check to ensure all is installed correctly (you will need Python, Jupyter, and IJulia kernel, see Getting Started)","category":"page"},{"location":"outputformats/#Steps-to-create-reports","page":"4. Output formats","title":"Steps to create reports","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Make sure you have the right header specifying which IJulia kernel to use (e.g. jupyter: julia-1.9), otherwise Quarto will use the default Python kernel.\nConvert your Literate.jl script to a .qmd file, e.g.\nLiterate.markdown(\"my_script.jl\", flavor = Literate.QuartoFlavor())\nRun Quarto CLI to produce your desired output format, e.g.\nquarto render my_script.qmd --to html","category":"page"},{"location":"outputformats/#Notebook-output","page":"4. Output formats","title":"4.2. Notebook output","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Notebook output is generated by Literate.notebook. The (default) notebook output of the source snippet can be seen here: notebook.ipynb.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"We note that lines starting with # are placed in markdown cells, and the code lines have been placed in code cells. By default the notebook is also executed and output cells populated. The current working directory is set to the specified output directory the notebook is executed.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"See the section about Configuration for how to configure the behavior and resulting output of Literate.notebook.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.notebook","category":"page"},{"location":"outputformats/#Literate.notebook","page":"4. Output formats","title":"Literate.notebook","text":"Literate.notebook(inputfile, outputdir=pwd(); config::AbstractDict=Dict(), kwargs...)\n\nGenerate a notebook from inputfile and write the result to outputdir.\n\nSee the manual section on Configuration for documentation of possible configuration with config and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"outputformats/#Notebook-metadata","page":"4. Output formats","title":"Notebook metadata","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Jupyter notebook cells (both code cells and markdown cells) can contain metadata. This is enabled in Literate by the %% token, similar to Jupytext. The format is as follows","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"%% optional ignored text [type] {optional metadata JSON}","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Cell metadata can, for example, be used for nbgrader and the reveal.js notebook extension RISE.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"The following would create a 3 slide deck with RISE:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"#nb # %% A slide [markdown] {\"slideshow\": {\"slide_type\": \"slide\"}}\n# # Some title\n#\n# We're using `#nb` so the metadata is only included in notebook output\n\n#nb %% A slide [code] {\"slideshow\": {\"slide_type\": \"fragment\"}}\nx = 1//3\ny = 2//5\n\n#nb # %% A slide [markdown] {\"slideshow\": {\"slide_type\": \"subslide\"}}\n# For more information about RISE, see [the docs](https://rise.readthedocs.io/en/stable/usage.html)","category":"page"},{"location":"outputformats/#Script-output","page":"4. Output formats","title":"4.3. Script output","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Script output is generated by Literate.script. The (default) script output of the source snippet above is as follows:","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"import Markdown\nfile = joinpath(@__DIR__,  \"../src/generated/outputformats.jl\")\nstr = \"```julia\\n\" * rstrip(read(file, String)) * \"\\n```\"\nrm(file)\nMarkdown.parse(str)","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"We note that lines starting with # are removed and only the code lines have been kept.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"See the section about Configuration for how to configure the behavior and resulting output of Literate.script.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.script","category":"page"},{"location":"outputformats/#Literate.script","page":"4. Output formats","title":"Literate.script","text":"Literate.script(inputfile, outputdir=pwd(); config::AbstractDict=Dict(), kwargs...)\n\nGenerate a plain script file from inputfile and write the result to outputdir.\n\nSee the manual section on Configuration for documentation of possible configuration with config and other keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"outputformats/#Configuration","page":"4. Output formats","title":"4.4. Configuration","text":"","category":"section"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"The behavior of Literate.markdown, Literate.notebook and Literate.script can be configured by keyword arguments. There are two ways to do this; pass config::Dict as a keyword argument, or pass individual keyword arguments.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"note: Configuration precedence\nIndividual keyword arguments take precedence over the config dictionary, so for e.g. Literate.markdown(...; config = Dict(\"name\" => \"hello\"), name = \"world\") the resulting configuration for name will be \"world\". Both individual keyword arguments and the config dictionary take precedence over the default.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Available configurations with description and default values are given in the reference for Literate.DEFAULT_CONFIGURATION just below.","category":"page"},{"location":"outputformats/","page":"4. Output formats","title":"4. Output formats","text":"Literate.DEFAULT_CONFIGURATION","category":"page"},{"location":"outputformats/#Literate.DEFAULT_CONFIGURATION","page":"4. Output formats","title":"Literate.DEFAULT_CONFIGURATION","text":"DEFAULT_CONFIGURATION\n\nDefault configuration for Literate.markdown, Literate.notebook and Literate.script which is used for everything not specified by the user. Configuration can be passed as individual keyword arguments or as a dictionary passed with the config keyword argument. See the manual section about Configuration for more information.\n\nAvailable options:\n\nname (default: filename(inputfile)): Name of the output file (excluding the file extension).\npreprocess (default: identity): Custom preprocessing function mapping a String to a String. See Custom pre- and post-processing.\npostprocess (default: identity): Custom preprocessing function mapping a String to a String. See Custom pre- and post-processing.\ncredit (default: true): Boolean for controlling the addition of This file was generated with Literate.jl ... to the bottom of the page. If you find Literate.jl useful then feel free to keep this.\nkeep_comments (default: false): When true, keeps markdown lines as comments in the output script. Only applicable for Literate.script.\nexecute (default: true for notebook, false for markdown): Whether to execute and capture the output. Only applicable for Literate.notebook and Literate.markdown.\ncontinue_on_error (default: false): Whether to continue code execution of remaining blocks after encountering an error. By default execution errors are re-thrown. If continue_on_error = true the error will be used as the output of the block instead and execution will continue. This option is only applicable when execute = true.\ncodefence (default: \"````@example $(name)\" => \"````\" for DocumenterFlavor() and \"````julia\" => \"````\" otherwise): Pair containing opening and closing code fence for wrapping code blocks.\nflavor (default: Literate.DocumenterFlavor()) Output flavor for markdown, see Markdown flavors. Only applicable for Literate.markdown.\ndevurl (default: \"dev\"): URL for \"in-development\" docs, see Documenter docs. Unused if repo_root_url/ nbviewer_root_url/binder_root_url are set.\nsoftscope (default: true for Jupyter notebooks, false otherwise): enable/disable \"soft\" scoping rules when executing, see e.g. https://github.com/JuliaLang/SoftGlobalScope.jl.\nrepo_root_url: URL to the root of the repository. Determined automatically on Travis CI, GitHub Actions and GitLab CI. Used for @__REPO_ROOT_URL__.\nnbviewer_root_url: URL to the root of the repository as seen on nbviewer. Determined automatically on Travis CI, GitHub Actions and GitLab CI. Used for @__NBVIEWER_ROOT_URL__.\nbinder_root_url: URL to the root of the repository as seen on mybinder. Determined automatically on Travis CI, GitHub Actions and GitLab CI. Used for @__BINDER_ROOT_URL__.\nimage_formats: A vector of (mime, ext) tuples, with the default Tuple{MIME, String}[(MIME type image/svg+xml, \".svg\"), (MIME type image/png, \".png\"), (MIME type image/jpeg, \".jpeg\")]. Results which are showable with a MIME type are saved with the first match, with the corresponding extension.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Literate","category":"page"},{"location":"reference/#Literate","page":"Reference","title":"Literate","text":"Literate\n\nJulia package for Literate Programming. See https://fredrikekre.github.io/Literate.jl/ for documentation.\n\n\n\n\n\n","category":"module"},{"location":"fileformat/#File-format","page":"2. File format","title":"2. File format","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The source file format for Literate is a regular, commented, julia (.jl) scripts. The idea is that the scripts also serve as documentation on their own and it is also simple to include them in the test-suite, with e.g. include, to make sure the examples stay up to date with other changes in your package.","category":"page"},{"location":"fileformat/#Syntax","page":"2. File format","title":"2.1. Syntax","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The basic syntax is simple:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"lines starting with # are treated as markdown,\nall other lines are treated as julia code.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Leading whitespace is allowed before #, but it will be removed when generating the output. Since #-lines are treated as markdown we can not use that for regular julia comments, for this you can instead use ##, which will render as # in the output.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Lets look at a simple example:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"# # Rational numbers\n#\n# In julia rational numbers can be constructed with the `//` operator.\n# Lets define two rational numbers, `x` and `y`:\n\n## Define variable x and y\nx = 1//3\ny = 2//5\n\n# When adding `x` and `y` together we obtain a new rational number:\n\nz = x + y","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"In the lines starting with # we can use regular markdown syntax, for example the # used for the heading and the backticks for formatting code. The other lines are regular julia code. We note a couple of things:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The script is valid julia, which means that we can include it and the example will run (for example in the test/runtests.jl script, to include the example in the test suite).\nThe script is \"self-explanatory\", i.e. the markdown lines works as comments and thus serve as good documentation on its own.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"For simple use this is all you need to know. The following additional special syntax can also be used:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#md, #nb, #jl, #src: tags to filter lines, see Filtering lines,\n#- (#+): tag to manually control chunk-splits, see Custom control over chunk splits.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"There is also some default convenience replacements that will always be performed, see Default replacements.","category":"page"},{"location":"fileformat/#Multiline-comments-and-markdown-strings","page":"2. File format","title":"Multiline comments and markdown strings","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Literate version 2.7 adds support for Julia multiline comments for markdown input. All multiline comments in the input are rewritten to regular comments as part of the preprocessing step, before any other processing is performed. For Literate to recognize multiline comments it is required that the start token (#=) and end token (=#) are placed on their own lines. Note also that it is allowed to have more than one = in the tokens, for example","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#=\nThis multiline comment\nis treated as markdown.\n=#\n\n#=====================\nThis is also markdown.\n=====================#","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"is rewritten to","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"# This multiline comment\n# is treated as markdown.\n\n# This is also markdown.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Similarly, Literate version 2.9 adds support for using literal markdown strings, md\"\"\" ... \"\"\", for the markdown sections, for example","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"md\"\"\"\n# Title\nblah blah blah\n\"\"\"","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"is rewritten to","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"# # Title\n# blah blah blah","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"This is not enabled by default – it requires passing mdstrings=true. Literate.markdown/Literate.notebook/Literate.script.","category":"page"},{"location":"fileformat/#Filtering-lines","page":"2. File format","title":"2.2. Filtering lines","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"It is often useful to filter out lines in the source depending on the output format. For this purpose there are a number of \"tokens\" that can be used to mark the purpose of certain lines:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#md: line exclusive to markdown output,\n#nb: line exclusive to notebook output,\n#jl: line exclusive to script output,\n#src: line exclusive to the source code and thus filtered out unconditionally.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Lines starting or ending with one of these tokens are filtered out in the preprocessing step. In addition, for markdown output, lines ending with #hide are filtered out similar to Documenter.jl.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"note: Difference between `#src` and `#hide`\n#src and #hide are quite similar. The only difference is that #src lines are filtered out before execution (if execute=true) and #hide lines are filtered out after execution.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"tip: Tip\nThe tokens can also be negated, for example a line starting with #!nb would be included in markdown and script output, but filtered out for notebook output.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"Suppose, for example, that we want to include a docstring within a @docs block using Documenter. Obviously we don't want to include this in the notebook, since @docs is Documenter syntax that the notebook will not understand. This is a case where we can prepend #md to those lines:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"#md # ```@docs\n#md # Literate.markdown\n#md # Literate.notebook\n#md # Literate.script\n#md # ```","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The lines in the example above would be filtered out in the preprocessing step, unless we are generating a markdown file. When generating a markdown file we would simply remove the leading #md from the lines. Beware that the space after the tag is also removed.","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The #src token can also be placed at the end of a line. This is to make it possible to have code lines exclusive to the source code, and not just comment lines. For example, if the source file is included in the test suite we might want to add a @test at the end without this showing up in the outputs:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"using Test                      #src\n@test result == expected_result #src","category":"page"},{"location":"fileformat/#Default-replacements","page":"2. File format","title":"2.3. Default replacements","text":"","category":"section"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"The following convenience \"macros\"/source placeholders are always expanded:","category":"page"},{"location":"fileformat/","page":"2. File format","title":"2. File format","text":"@__NAME__:\nexpands to the name keyword argument to Literate.markdown, Literate.notebook and Literate.script (defaults to the filename of the input file).\n@__REPO_ROOT_URL__:\nCan be used to link to files in the repository. For example @__REPO_ROOT_URL__/src/Literate.jl would link to the source of the Literate module. This variable is automatically determined on Travis CI, GitHub Actions and GitLab CI, but can be configured, see Configuration.\n@__NBVIEWER_ROOT_URL__:\nCan be used if you want a link that opens the generated notebook in http://nbviewer.jupyter.org/. This variable is automatically determined on Travis CI, GitHub Actions and GitLab CI, but can be configured, see Configuration.\n@__BINDER_ROOT_URL__:\nCan be used if you want a link that opens the generated notebook in https://mybinder.org/. For example, to add a binder-badge in e.g. the HTML output you can use:\n[![Binder](https://mybinder.org/badge_logo.svg)](@__BINDER_ROOT_URL__/path/to/notebook.inpynb)\nThis variable is automatically determined on Travis CI, GitHub Actions and GitLab CI, but can be configured, see Configuration.","category":"page"},{"location":"#Introduction","page":"1. Introduction","title":"1. Introduction","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Welcome to the documentation for Literate  – a simplistic package for Literate Programming.","category":"page"},{"location":"#What?","page":"1. Introduction","title":"What?","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Literate is a package that generates markdown pages (for e.g. Documenter.jl), and Jupyter notebooks, from the same source file. There is also an option to \"clean\" the source from all metadata, and produce a pure Julia script.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"The main design goal is simplicity. It should be simple to use, and the syntax should be simple. In short, all you have to do is to write a commented julia script!","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"The public interface consists of three functions, all of which take the same script file as input, but generate different output:","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Literate.markdown generates a markdown file. Code snippets can be executed and the results included in the output.\nLiterate.notebook generates a notebook. Code snippets can be executed and the results included in the output.\nLiterate.script generates a plain script file scrubbed from all metadata and special syntax.","category":"page"},{"location":"#Why?","page":"1. Introduction","title":"Why?","text":"","category":"section"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Examples are (probably) the best way to showcase your awesome package, and examples are often the best way for a new user to learn how to use it. It is therefore important that the documentation of your package contains examples for users to read and study. However, people are different, and we all prefer different ways of trying out a new package. Some people want to RTFM, others want to explore the package interactively in, for example, a notebook, and some people want to study the source code. The aim of Literate is to make it easy to give the user all of these options, while still keeping maintenance to a minimum.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"It is quite common that packages have \"example notebooks\" to showcase the package. Notebooks are great for showcasing a package, but they are not so great with version control, like git. The reason being that a notebook is a very \"rich\" format since it contains output and other metadata. Changes to the notebook thus result in large diffs, which makes it harder to review the actual changes.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"It is also common that packages include examples in the documentation, for example by using Documenter.jl @example-blocks. This is also great, but it is not quite as interactive as a notebook, for the users who prefer that.","category":"page"},{"location":"","page":"1. Introduction","title":"1. Introduction","text":"Literate tries to solve the problems above by creating the output as a part of the doc build. Literate generates the output based on a single source file which makes it easier to maintain, test, and keep the manual and your example notebooks in sync.","category":"page"}]
}
