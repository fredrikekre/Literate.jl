<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>3. Processing pipeline · Literate.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://fredrikekre.github.io/Literate.jl/v2/pipeline/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Literate.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Literate.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../"><strong>1.</strong> Introduction</a></li><li><a class="tocitem" href="../fileformat/"><strong>2.</strong> File format</a></li><li class="is-active"><a class="tocitem" href><strong>3.</strong> Processing pipeline</a><ul class="internal"><li><a class="tocitem" href="#Pre-processing"><span><strong>3.1.</strong> Pre-processing</span></a></li><li><a class="tocitem" href="#Parsing"><span><strong>3.2.</strong> Parsing</span></a></li><li><a class="tocitem" href="#Document-generation"><span><strong>3.3.</strong> Document generation</span></a></li><li><a class="tocitem" href="#Post-processing"><span><strong>3.4.</strong> Post-processing</span></a></li><li><a class="tocitem" href="#Writing-to-file"><span><strong>3.5.</strong> Writing to file</span></a></li></ul></li><li><a class="tocitem" href="../outputformats/"><strong>4.</strong> Output formats</a></li><li><a class="tocitem" href="../customprocessing/"><strong>5.</strong> Custom pre- and post-processing</a></li><li><a class="tocitem" href="../documenter/"><strong>6.</strong> Interaction with Documenter.jl</a></li><li><a class="tocitem" href="../tips/"><strong>7.</strong> Tips and tricks</a></li><li><a class="tocitem" href="../generated/example/"><strong>8.</strong> Example</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href><strong>3.</strong> Processing pipeline</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href><strong>3.</strong> Processing pipeline</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fredrikekre/Literate.jl/blob/master/docs/src/pipeline.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Processing-pipeline"><a class="docs-heading-anchor" href="#Processing-pipeline"><strong>3.</strong> Processing pipeline</a><a id="Processing-pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Processing-pipeline" title="Permalink"></a></h1><p>The generation of output follows the same pipeline for all output formats:</p><ol><li><a href="#Pre-processing">Pre-processing</a></li><li><a href="#Parsing">Parsing</a></li><li><a href="#Document-generation">Document generation</a></li><li><a href="#Post-processing">Post-processing</a></li><li><a href="#Writing-to-file">Writing to file</a></li></ol><h2 id="Pre-processing"><a class="docs-heading-anchor" href="#Pre-processing"><strong>3.1.</strong> Pre-processing</a><a id="Pre-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-processing" title="Permalink"></a></h2><p>The first step is pre-processing of the input file. The file is read to a <code>String</code>. The first processing step is to apply the user specified pre-processing function, see <a href="../customprocessing/#Custom-pre-and-post-processing">Custom pre- and post-processing</a>.</p><p>The next step is to perform all of the built-in default replacements. CRLF style line endings (<code>&quot;\r\n&quot;</code>) are replaced with LF line endings (<code>&quot;\n&quot;</code>) to simplify internal processing. Next, line filtering is performed, see <a href="../fileformat/#Filtering-lines">Filtering lines</a>, meaning that lines starting with <code>#md</code>, <code>#nb</code> or <code>#jl</code> are handled (either just the token itself is removed, or the full line, depending on the output target). The last pre-processing step is to expand the convenience &quot;macros&quot; described in <a href="../fileformat/#Default-replacements">Default replacements</a> is expanded.</p><h2 id="Parsing"><a class="docs-heading-anchor" href="#Parsing"><strong>3.2.</strong> Parsing</a><a id="Parsing-1"></a><a class="docs-heading-anchor-permalink" href="#Parsing" title="Permalink"></a></h2><p>After the preprocessing the file is parsed. The first step is to categorize each line and mark them as either markdown or code according to the rules described in the <a href="../fileformat/#Syntax">Syntax</a> section. Lets consider the example from the previous section with each line categorized:</p><pre><code class="nohighlight hljs"># # Rational numbers                                                     &lt;- markdown
#                                                                        &lt;- markdown
# In julia rational numbers can be constructed with the `//` operator.   &lt;- markdown
# Lets define two rational numbers, `x` and `y`:                         &lt;- markdown
                                                                         &lt;- code
## Define variable x and y                                               &lt;- code
x = 1 // 3                                                               &lt;- code
y = 2 // 5                                                               &lt;- code
                                                                         &lt;- code
# When adding `x` and `y` together we obtain a new rational number:      &lt;- markdown
                                                                         &lt;- code
z = x + y                                                                &lt;- code</code></pre><p>In the next step the lines are grouped into &quot;chunks&quot; of markdown and code. This is done by simply collecting adjacent lines of the same &quot;type&quot; into chunks:</p><pre><code class="nohighlight hljs"># # Rational numbers                                                     ┐
#                                                                        │
# In julia rational numbers can be constructed with the `//` operator.   │ markdown
# Lets define two rational numbers, `x` and `y`:                         ┘
                                                                         ┐
## Define variable x and y                                               │
x = 1 // 3                                                               │
y = 2 // 5                                                               │ code
                                                                         ┘
# When adding `x` and `y` together we obtain a new rational number:      ] markdown
                                                                         ┐
z = x + y                                                                ┘ code</code></pre><p>In the last parsing step all empty leading and trailing lines for each chunk are removed, but empty lines <em>within the same</em> block are kept. The leading <code>#</code> tokens are also removed from the markdown chunks. Finally we would end up with the following 4 chunks:</p><p>Chunks #1:</p><pre><code class="language-markdown hljs"># Rational numbers

In julia rational numbers can be constructed with the `//` operator.
Lets define two rational numbers, `x` and `y`:</code></pre><p>Chunk #2:</p><pre><code class="language-julia hljs"># Define variable x and y
x = 1 // 3
y = 2 // 5</code></pre><p>Chunk #3:</p><pre><code class="language-markdown hljs">When adding `x` and `y` together we obtain a new rational number:</code></pre><p>Chunk #4:</p><pre><code class="language-julia hljs">z = x + y</code></pre><p>It is then up to the <a href="#Document-generation">Document generation</a> step to decide how these chunks should be treated.</p><h3 id="Custom-control-over-chunk-splits"><a class="docs-heading-anchor" href="#Custom-control-over-chunk-splits">Custom control over chunk splits</a><a id="Custom-control-over-chunk-splits-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-control-over-chunk-splits" title="Permalink"></a></h3><p>Sometimes it is convenient to be able to manually control how the chunks are split. For example, if you want to split a block of code into two, such that they end up in two different <code>@example</code> blocks or notebook cells. The <code>#-</code> token can be used for this purpose. All lines starting with <code>#-</code> are used as &quot;chunk-splitters&quot;:</p><pre><code class="language-julia hljs">x = 1 // 3
y = 2 // 5
#-
z = x + y</code></pre><p>The example above would result in two consecutive code-chunks.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The rest of the line, after <code>#-</code>, is discarded, so it is possible to use e.g. <code>#-------------</code> as a chunk splitter, which may make the source code more readable.</p></div></div><p>It is also possible to use <code>#+</code> as a chunk splitter. The difference between <code>#+</code> and <code>#-</code> is that <code>#+</code> enables Documenter&#39;s &quot;continued&quot;-blocks, see the <a href="https://juliadocs.github.io/Documenter.jl/stable/">Documenter manual</a>.</p><h2 id="Document-generation"><a class="docs-heading-anchor" href="#Document-generation"><strong>3.3.</strong> Document generation</a><a id="Document-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Document-generation" title="Permalink"></a></h2><p>After the parsing it is time to generate the output. What is done in this step is very different depending on the output target, and it is described in more detail in the Output format sections: <a href="../outputformats/#Markdown-output">Markdown output</a>, <a href="../outputformats/#Notebook-output">Notebook output</a> and <a href="../outputformats/#Script-output">Script output</a>. Using the default settings, the following is happening:</p><ul><li>Markdown output: markdown chunks are printed as-is, code chunks are put inside a code fence (defaults to <code>@example</code>-blocks),</li><li>Notebook output: markdown chunks are printed in markdown cells, code chunks are put in code cells,</li><li>Script output: markdown chunks are discarded, code chunks are printed as-is.</li></ul><h2 id="Post-processing"><a class="docs-heading-anchor" href="#Post-processing"><strong>3.4.</strong> Post-processing</a><a id="Post-processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-processing" title="Permalink"></a></h2><p>When the document is generated the user, again, has the option to hook-into the generation with a custom post-processing function. The reason is that one might want to change things that are only visible in the rendered document. See <a href="../customprocessing/#Custom-pre-and-post-processing">Custom pre- and post-processing</a>.</p><h2 id="Writing-to-file"><a class="docs-heading-anchor" href="#Writing-to-file"><strong>3.5.</strong> Writing to file</a><a id="Writing-to-file-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-to-file" title="Permalink"></a></h2><p>The last step of the generation is writing to file. The result is written to <code>$(outputdir)/$(name)(.md|.ipynb|.jl)</code> where <code>outputdir</code> is the output directory supplied by the user (for example <code>docs/generated</code>), and <code>name</code> is a user supplied filename. It is recommended to add the output directory to <code>.gitignore</code> since the idea is that the generated documents will be generated as part of the build process rather than beeing files in the repo.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fileformat/">« <strong>2.</strong> File format</a><a class="docs-footer-nextpage" href="../outputformats/"><strong>4.</strong> Output formats »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 15 September 2021 08:41">Wednesday 15 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
